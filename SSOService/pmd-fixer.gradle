/**
 * PMD Auto-Fixer Script
 * Автоматическое исправление распространенных ошибок PMD
 */

tasks.register('pmdFix') {
    group = 'code quality'
    description = 'Automatically fix common PMD violations'

    doLast {
        def fixCount = 0
        def skippedCount = 0

        println """
        ╔════════════════════════════════════════════════════════╗
        ║           PMD Auto-Fixer - Starting...                ║
        ╚════════════════════════════════════════════════════════╝
        """.stripIndent()

        // Получаем список всех Java файлов
        def javaFiles = fileTree(dir: 'src', include: '**/*.java')

        javaFiles.each { file ->
            def content = file.text
            def originalContent = content
            def fileFixCount = 0

            // 1. UnnecessaryImport - удаление неиспользуемых импортов
            content = removeUnusedImports(content, file)

            // 2. AvoidDuplicateLiterals - извлечение констант
            // (требует анализа контекста, пропускаем автоматическое исправление)

            // 3. UseConcurrentHashMap - замена HashMap на ConcurrentHashMap в многопоточном коде
            // (требует анализа контекста, пропускаем)

            // 4. GuardLogStatement - добавление проверок уровня логирования
            content = addLogGuards(content)

            // 5. UnusedLocalVariable - удаление неиспользуемых переменных
            // (требует полного анализа, пропускаем)

            // 6. ControlStatementBraces - добавление фигурных скобок
            content = addBracesToControlStatements(content)

            // 7. UseLocaleWithCaseConversions - добавление Locale
            content = addLocaleToStringConversion(content)

            // 8. UseExplicitTypes - замена var на явные типы
            content = replaceVarWithExplicitTypes(content)

            // 9. JUnit naming conventions - исправление названий тестов
            content = fixJUnitTestNaming(content)

            // 10. UnnecessaryAnnotationValueElement - упрощение аннотаций
            content = simplifyAnnotations(content)

            if (content != originalContent) {
                file.text = content
                fileFixCount++
                fixCount++
                println "  ✓ Fixed: ${file.name}"
            }
        }

        println """
        ╔════════════════════════════════════════════════════════╗
        ║           PMD Auto-Fixer - Completed ✓                ║
        ╠════════════════════════════════════════════════════════╣
        ║ Fixed files: ${fixCount}                                        ║
        ║ Skipped (manual): ${skippedCount}                               ║
        ╠════════════════════════════════════════════════════════╣
        ║ ⚠️  Note: Some violations require manual fixing:       ║
        ║   • AvoidDuplicateLiterals (extract constants)        ║
        ║   • UseConcurrentHashMap (threading analysis needed)  ║
        ║   • UnusedLocalVariable (usage analysis needed)       ║
        ║   • TooManyFields/GodClass (refactoring needed)       ║
        ╚════════════════════════════════════════════════════════╝
        """.stripIndent()
    }
}

def removeUnusedImports(String content, File file) {
    // Простое удаление очевидно неиспользуемых импортов
    def lines = content.split('\n')
    def imports = []
    def codeLines = []
    def inImportSection = false

    lines.each { line ->
        if (line.trim().startsWith('import ')) {
            inImportSection = true
            imports << line
        } else if (inImportSection && line.trim().isEmpty()) {
            codeLines << line
        } else {
            inImportSection = false
            codeLines << line
        }
    }

    // Фильтруем импорты, которые используются в коде
    def usedImports = imports.findAll { importLine ->
        def className = importLine.replaceAll(/.*import\s+(static\s+)?/, '').replaceAll(/;.*/, '').trim()
        def simpleName = className.split(/\./).last()

        // Проверяем, используется ли класс в коде
        codeLines.any { it.contains(simpleName) }
    }

    // Собираем обратно
    def result = []
    def addedImports = false

    lines.each { line ->
        if (line.trim().startsWith('import ')) {
            if (!addedImports) {
                result.addAll(usedImports)
                result << ''
                addedImports = true
            }
        } else {
            result << line
        }
    }

    return result.join('\n')
}

def addLogGuards(String content) {
    // Добавляем проверки уровня логирования
    content = content.replaceAll(
        /(\s+)log\.debug\((.*?)\);/,
        '$1if (log.isDebugEnabled()) {\n$1    log.debug($2);\n$1}'
    )
    content = content.replaceAll(
        /(\s+)log\.trace\((.*?)\);/,
        '$1if (log.isTraceEnabled()) {\n$1    log.trace($2);\n$1}'
    )
    return content
}

def addBracesToControlStatements(String content) {
    // Добавляем фигурные скобки к if/for/while без них
    content = content.replaceAll(
        /(\s+)(if|for|while)\s*\((.*?)\)\s*\n\s*([^{].*?);/,
        '$1$2 ($3) {\n$1    $4;\n$1}'
    )
    return content
}

def addLocaleToStringConversion(String content) {
    // Добавляем Locale.ROOT к toLowerCase/toUpperCase
    content = content.replaceAll(
        /\.toLowerCase\(\)/,
        '.toLowerCase(Locale.ROOT)'
    )
    content = content.replaceAll(
        /\.toUpperCase\(\)/,
        '.toUpperCase(Locale.ROOT)'
    )

    // Добавляем импорт Locale если его нет
    if (content.contains('Locale.ROOT') && !content.contains('import java.util.Locale')) {
        content = content.replaceFirst(
            /(package .*?;\n)/,
            '$1\nimport java.util.Locale;\n'
        )
    }

    return content
}

def replaceVarWithExplicitTypes(String content) {
    // Замена var на явные типы (простые случаи)
    // Это сложная задача, требующая полного анализа типов
    // Пропускаем автоматическое исправление
    return content
}

def fixJUnitTestNaming(String content) {
    // Исправление названий JUnit тестов на camelCase
    content = content.replaceAll(
        /@Test\s+public\s+void\s+([a-zA-Z]+)_([a-zA-Z_]+)\(/,
        { match, prefix, suffix ->
            def camelCase = prefix + suffix.split('_').collect {
                it.capitalize()
            }.join('')
            return "@Test\n    public void ${camelCase}("
        }
    )
    return content
}

def simplifyAnnotations(String content) {
    // Упрощение аннотаций с value =
    content = content.replaceAll(
        /@([A-Z][a-zA-Z]+)\(value\s*=\s*"(.*?)"\)/,
        '@$1("$2")'
    )
    content = content.replaceAll(
        /@([A-Z][a-zA-Z]+)\(value\s*=\s*([^,)]+)\)/,
        '@$1($2)'
    )
    return content
}

tasks.register('pmdFixAndCheck') {
    group = 'code quality'
    description = 'Fix PMD violations and run checks again'

    dependsOn pmdFix
    finalizedBy pmdMain, pmdTest

    doLast {
        println """
        ╔════════════════════════════════════════════════════════╗
        ║      PMD Fix & Check - Completed ✓                    ║
        ╠════════════════════════════════════════════════════════╣
        ║ Run 'gradlew pmdMain' to see remaining violations     ║
        ╚════════════════════════════════════════════════════════╝
        """.stripIndent()
    }
}

